<!doctype html>
<html>
  <head>
    <title>veldhuizen-engine</title>
    <!--<script type="text/javascript" src="r66.three.min.js"></script>-->
    <script type="text/javascript" src="r82.three.min.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="veldhuizen_engine.js"></script>
    <link rel="stylesheet" type="text/css" href="index.css">
  </head>
  <body>
    <a href="https://github.com/thwee-alchemist/veldhuizen-engine"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    <div id="veldhuizen-engine"></div>
    
    <script type="text/javascript">
    
      veldhuizen_engine = new VeldhuizenEngine();
      veldhuizen_engine.init('#veldhuizen-engine', {
        width: window.width,
        height: window.height,
        window: window,
        resize: true,
        manual_layout: true
      });
      
      controls = new THREE.OrbitControls( veldhuizen_engine.camera, veldhuizen_engine.renderer.domElement );
      
      var GRAPH_SIZE = 100;
      var VERTICES = 100;
      var vertices = [];
      
      /*
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-1000, -1000, -1000));
      geometry.vertices.push(new THREE.Vector3(1000, 1000, 1000));
      var material = new THREE.LineBasicMaterial({ color: 0x000000 });
      var line = new THREE.Line( geometry, material );
      */
      
      /*
      while(vertices.length < 100){
        var vertex = veldhuizen_engine.graph.add_vertex({
          size: 100,
          color: 0x800000
        });
        
        vertices.push(vertex);
      }
      
      veldhuizen_engine.render_functions.push(function(){
        // remove vertex
        to_delete = vertices[Math.round(Math.random() * VERTICES)];
        veldhuizen_engine.graph.remove_vertex(to_delete);

        // add vertex
        var vertex = veldhuizen_engine.graph.add_vertex({
          size: 100,
          color: 0x800000
        });
        vertices.push(vertex);
      
        // add edge
        var v1 = vertices[Math.round(Math.random() * VERTICES)];
        var v2 = vertices[Math.round(Math.random() * VERTICES)];
        
        veldhuizen_engine.graph.add_edge(v1, v2);
        
        controls.update();
      });
      */
      
      var graph = veldhuizen_engine.graph;
      var v1 = graph.add_vertex({color: 0x800000, size: 1});
      var v2 = graph.add_vertex({color: 0x800000, size: 1});
      var e = graph.add_edge(v1, v2);
      
      // 261.6 - 493.9
      
      
      var choice = function(arr){ 
        return arr[Math.round(Math.random() * arr.length)]; 
      };   
      // var e1 = graph.add_edge(v1, v2);
      
      var distanceTravelled = new THREE.Vector3(0,0,0);
      var position = new THREE.Vector3(0, 0, 0);
      
      var assign_repulsion = function(v){
        CONSTANTS.BHN3.repulsion = v;
      };
      
      var get_repulsion = function(){
        return CONSTANTS.BHN3.repulsion;
      };
      
      var assign_attraction = function(v){
        CONSTANTS.BHN3.attraction = v;
      };
      
      var get_attraction = function(){
        return CONSTANTS.BHN3.attraction;
      };
              
      var vary = function(name, assign, get, min_order, max_order){
        var i = min_order;
        assign(i);
        console.log(name, get());
        var up = true;
        
        var interval = setInterval(function(){
          
          if(up){
            i = i*10;
          }else{
            i = i/10;
          }
          
          if(up && get() > max_order){
            up = false;
          }else if(!up && get() <= min_order){
            clearInterval(interval);
          }
          assign(i);
          console.log(name, get());
        }, 100);
      };
        

      var min = 1;
      var max = 100;
      var min_f = 261.6;
      var max_f = 493.9;
      var context = new AudioContext();
      var makeNote = function(e){
        var length = e.source.object.position.clone().sub(
          e.target.object.position
        ).length();
                
        var length_fraction = (length - min)/(max - min);
        var frequency = (length_fraction*(max_f-min_f))+min_f;
        frequency = Math.round(frequency*10)/10;        
        
        var o = context.createOscillator();
        var g = context.createGain();
        o.type = 'sine';
        o.connect(g);
        o.frequency.value = frequency;
        g.connect(context.destination);
        o.start(0);
        g.gain.exponentialRampToValueAtTime(0.000001, context.currentTime+ 1);

      };
      
      veldhuizen_engine.render_functions.push(function(){
        distanceTravelled.add(v1.object.position.clone().sub(position));
        position = v1.object.position.clone();
        // makeNote();
        // console.log(distanceTravelled.length());
        controls.update();
      });
      
      var f_interval;
      randomInterval = function(f){
        f_interval = setInterval(
          function(){
            f(); 
            clearInterval(f_interval); 
            randomInterval(f)
          }, 
          Math.random() * 1000
        );
      };
      
      /*
      randomInterval(function(){
        makeNote(e)
      });
      */
      
      for(var i=0; i<100; i++){ graph.add_vertex({color: 0x800000, size: 1}) };
      while(graph.E.length < 100){ try{ graph.add_edge(choice(graph.V), choice(graph.V)); }catch(e){ 1+1 } };
      
      // for(var i=0; i<300; i++){ graph.add_edge(choice(graph.V), choice(graph.V)); };
      
    </script>
  </body>
</html>
